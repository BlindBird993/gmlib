# ###############################################################################
# #
# # Copyright (C) 1994 Narvik University College
# # Contact: GMlib Online Portal at http://episteme.hin.no
# #
# # This file is part of the Geometric Modeling Library, GMlib.
# #
# # GMlib is free software: you can redistribute it and/or modify
# # it under the terms of the GNU Lesser General Public License as published by
# # the Free Software Foundation, either version 3 of the License, or
# # (at your option) any later version.
# #
# # GMlib is distributed in the hope that it will be useful,
# # but WITHOUT ANY WARRANTY; without even the implied warranty of
# # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# # GNU Lesser General Public License for more details.
# #
# # You should have received a copy of the GNU Lesser General Public License
# # along with GMlib. If not, see <http://www.gnu.org/licenses/>.
# #
# ###############################################################################

# JOIN function to join lists
# ref: Andrey Kamaev - stackoverflow.com
# http://stackoverflow.com/questions/7172670/best-shortest-way-to-join-a-list-in-cmake
function(JOIN VALUES GLUE OUTPUT)
  string (REGEX REPLACE "([^\\]|^);" "\\1${GLUE}" _TMP_STR "${VALUES}")
  string (REGEX REPLACE "[\\](.)" "\\1" _TMP_STR "${_TMP_STR}") #fixes escaping
  set (${OUTPUT} "${_TMP_STR}" PARENT_SCOPE)
endfunction()

# Set a library prefix
macro(setLibPrefix PREFIX)
  set( LIB_PREFIX ${PREFIX} )
endmacro(setLibPrefix)

# Set a module suffix
macro(setModuleSuffix SUFFIX)
  set( MODULE_SUFFIX ${SUFFIX} )
endmacro(setModuleSuffix)

# Set template dir
macro(setTemplateDir DIR)
  set( ICMAKE_TEMPLATE_DIR ${DIR} )
endmacro(setTemplateDir)
# Setup library
macro(setupLibrary NAME VERSION_MAJOR VERSION_MINOR VERSION_PATCH )

  # Library name
  set( LIBRARY_NAME ${NAME} )
  string( TOLOWER ${LIBRARY_NAME} LIBRARY )
  string( TOUPPER ${LIBRARY_NAME} LIBRARY_NAME_UPPER )

  # Set library prefix
  setLibPrefix( "gm" )
  setModuleSuffix( "Module" )

  # Project name
  project( ${LIBRARY_NAME} )

  # Version
  set( LIBRARY_VERSION_MAJOR ${VERSION_MAJOR} )
  set( LIBRARY_VERSION_MINOR ${VERSION_MINOR} )
  set( LIBRARY_VERSION_PATCH ${VERSION_PATCH} )

  # Namespace
  if( NOT DISABLE_NAMESPACE )
    set( VAR_NAMESPACE_OPEN  "namespace ${LIBRARY_NAME} {" )
    set( VAR_NAMESPACE_CLOSE "}" )
  endif()

  # Define build directories
  set( BUILD_DIR ${CMAKE_BINARY_DIR}/build )
  set( BUILD_INCLUDE_DIR
       ${BUILD_DIR}/include/${LIBRARY} )
  set( BUILD_LIB_DIR
       ${BUILD_DIR}/lib/${LIBRARY} )

  message( "Lib build dir:         " ${BUILD_DIR} )
  message( "Lib build/include dir: " ${BUILD_INCLUDE_DIR} )
  message( "Lib build/lib dir:     " ${BUILD_LIB_DIR} )

  # Generate build directories
  execute_process(
    COMMAND ${CMAKE_COMMAND} -E make_directory ${BUILD_INCLUDE_DIR}
    COMMAND ${CMAKE_COMMAND} -E make_directory ${BUILD_LIB_DIR}
  )

  # Set a file config/generate message
  getLibraryVersionStr( LIB_VSTR )
  set( VAR_GENERATE_MESSAGE "This file was generated by CMake for ${LIBRARY_NAME} v${LIB_VSTR}." )

endmacro(setupLibrary)

# Returns the set library version string in the form of <major.minor.patch>.
function(getLibraryVersionStr LIB_VERSION_STR)

  set( ${LIB_VERSION_STR} "${LIBRARY_VERSION_MAJOR}.${LIBRARY_VERSION_MINOR}.${LIBRARY_VERSION_PATCH}" PARENT_SCOPE )
endfunction(getLibraryVersionStr)

# Add module function (must be called from module-parent directory (CMakeFile.txt)
macro(addModule NAME)

  # Setup the module
  setupModule( ${NAME} )

  # Look for files and stuff in module directory
  add_subdirectory( ${MODULE} )

  # Finalize module
  finalizeModule()

endmacro(addModule)

# Setup function for a module
macro(setupModule NAME)

  # set vars
  set( MODULE_NAME ${NAME} )
  string( TOLOWER ${MODULE_NAME} MODULE )
  set( MODULE_TARGET ${LIB_PREFIX}${MODULE} )
  set( MODULE_DIR ${CMAKE_CURRENT_SOURCE_DIR}/${MODULE} )

  message( "Module name: " ${MODULE_NAME} )
  message( "Module:      " ${MODULE} )
  message( "Module dir:  " ${MODULE_DIR} )

  # Define build directories
  set( MODULE_BUILD_INCLUDE_DIR "${BUILD_INCLUDE_DIR}/${MODULE}" )

  # Generate module build directories
  execute_process(
    COMMAND ${CMAKE_COMMAND} -E make_directory ${MODULE_BUILD_INCLUDE_DIR}
  )


  # Clear cache
  unset( HEADERS CACHE )
  unset( SOURCES CACHE )
  unset( TEMPLATE_SOURCES CACHE )

endmacro(setupModule)

# Functions for adding source files and propagating these to the parent directory
macro(addHeaders)
  addSourceFiles2( ${MODULE_DIR} HEADERS ${ARGV} )
endmacro(addHeaders)

macro(addTemplateSources)
  addSourceFiles3( ${MODULE_DIR} TEMPLATE_SOURCES ${ARGV} )
endmacro(addTemplateSources)

macro(addSources)
  addSourceFiles( ${MODULE_DIR} SOURCES ${ARGV} )
endmacro(addSources)

macro(addSourceFiles MOD_DIR VAR)

  file( RELATIVE_PATH REL_PATH "${MOD_DIR}" "${CMAKE_CURRENT_SOURCE_DIR}" )
  foreach( SOURCE ${ARGN} )

    if( REL_PATH )
      list( APPEND ${VAR} "${REL_PATH}/${SOURCE}" )
    else()
      list( APPEND ${VAR} ${SOURCE} )
    endif()
  endforeach()

  set( ${VAR} ${${VAR}} CACHE INTERNAL "My cache" )
endmacro(addSourceFiles)

macro(addSourceFiles2 MOD_DIR VAR)

  file( RELATIVE_PATH REL_PATH "${MOD_DIR}" "${CMAKE_CURRENT_SOURCE_DIR}" )
  foreach( SOURCE ${ARGN} )

    # build entry (name,header,relative path) e.g.: [gmGlobal;gmGlobal.h;core]
    list( APPEND ${SOURCE} ${SOURCE} )

    string( TOLOWER ${SOURCE} SOURCE_LOWER )
    list( APPEND ${SOURCE} ${SOURCE_LOWER}.h )

    list( APPEND ${SOURCE} "RELPATH${REL_PATH}" )

    set( ${SOURCE} ${${SOURCE}} CACHE INTERNAL "My cache" )

#    message( "Entry: " ${${SOURCE}} )

    # add entry to list
    list( APPEND ${VAR} ${SOURCE} )

  endforeach()

  set( ${VAR} ${${VAR}} CACHE INTERNAL "My cache" )

endmacro(addSourceFiles2)

macro(addSourceFiles3 MOD_DIR VAR)

  file( RELATIVE_PATH REL_PATH "${MOD_DIR}" "${CMAKE_CURRENT_SOURCE_DIR}" )
  foreach( SOURCE ${ARGN} )

    # build entry (name,header,relative path) e.g.: [gmGlobal;gmGlobal.h;core]
    list( APPEND ${SOURCE} ${SOURCE} )
    list( APPEND ${SOURCE} "RELPATH${REL_PATH}" )

    set( ${SOURCE} ${${SOURCE}} CACHE INTERNAL "My cache" )

#    message( "Entry: " ${${SOURCE}} )

    # add entry to list
    list( APPEND ${VAR} ${SOURCE} )

  endforeach()

  set( ${VAR} ${${VAR}} CACHE INTERNAL "My cache" )

endmacro(addSourceFiles3)

# Function which finalizes the module by setting up linker targest
# as well as pos-process hooks
macro(finalizeModule)

  # Add files to the library
  addModuleLibrary()

  # Set target properties
  setModuleTargetProperties()

  # Add cxx header generation target
  generateModuleCXXHeaders()

  # Copy module header files to build directory if this is an out of source build
  createModuleCopyCmds()

  #######################
  # Post-build copy files
  #set( FILES_CPY ${HDRS} )
  #add_module_cpy_commands( ${MODULE} ${MODULE_TARGET} ${FILES_CPY} )

  printModuleSourceFiles()
endmacro(finalizeModule)

# Add a subdirectory inside a module
macro(addSubDirectory NAME)

  add_subdirectory( ${NAME} )

  file( RELATIVE_PATH SRC_CSRC_RELPATH "${CMAKE_SOURCE_DIR}/src" "${CMAKE_CURRENT_SOURCE_DIR}" )
  set( NEW_DIR ${BUILD_LIB_DIR}/${SRC_CSRC_RELPATH}/${NAME} )
  message( "New Dir: " ${NEW_DIR} )

  add_custom_command( TARGET ${MODULE_TARGET} PRE_BUILD
    COMMAND ${CMAKE_COMMAND} -E make_directory ${NEW_DIR}
  )

endmacro(addSubDirectory)

# Copy module headers to build/include directory
function(createModuleCopyCmds)

  # IF OUT OF SOURCE BUILD ... DO!!
  file( RELATIVE_PATH BIN_SRC_RELPATH "${CMAKE_BINARY_DIR}" "${CMAKE_SOURCE_DIR}" )
  if( BIN_SRC_RELPATH )

    # Copy headers
    foreach( HDR_SET ${HEADERS} )
      list( GET ${HDR_SET} 1 HDR_FILE )
      list( GET ${HDR_SET} 2 HDR_LOC )

      extractHeaderRelPath( ${HDR_LOC} HDR_LOC_MOD )
      if( HDR_LOC_MOD )
        add_custom_command( TARGET ${MODULE_TARGET} POST_BUILD
          COMMAND ${CMAKE_COMMAND} -E copy
            ${CMAKE_SOURCE_DIR}/src/${MODULE}/${HDR_LOC_MOD}/${HDR_FILE}
            ${MODULE_BUILD_INCLUDE_DIR}/${HDR_LOC_MOD}/${HDR_FILE}
        )
      else()
        add_custom_command( TARGET ${MODULE_TARGET} POST_BUILD
          COMMAND ${CMAKE_COMMAND} -E copy
            ${CMAKE_SOURCE_DIR}/src/${MODULE}/${HDR_FILE}
            ${MODULE_BUILD_INCLUDE_DIR}/${HDR_FILE}
        )
      endif()
    endforeach()

    # Copy template source files
    foreach( SRC_SET ${TEMPLATE_SOURCES} )
      list( GET ${SRC_SET} 0 SRC_FILE )
      list( GET ${SRC_SET} 1 SRC_LOC )

      extractHeaderRelPath( ${SRC_LOC} SRC_LOC_MOD )
      if( SRC_LOC_MOD )
        add_custom_command( TARGET ${MODULE_TARGET} POST_BUILD
          COMMAND ${CMAKE_COMMAND} -E copy
            ${CMAKE_SOURCE_DIR}/src/${MODULE}/${SRC_LOC_MOD}/${SRC_FILE}
            ${MODULE_BUILD_INCLUDE_DIR}/${SRC_LOC_MOD}/${SRC_FILE}
        )
      else()
        add_custom_command( TARGET ${MODULE_TARGET} POST_BUILD
          COMMAND ${CMAKE_COMMAND} -E copy
            ${CMAKE_SOURCE_DIR}/src/${MODULE}/${SRC_FILE}
            ${MODULE_BUILD_INCLUDE_DIR}/${SRC_FILE}
        )
      endif()
    endforeach()

    # Copy buildt library
    add_custom_command( TARGET ${MODULE_TARGET} POST_BUILD
      COMMAND ${CMAKE_COMMAND} -E copy
        ${CMAKE_BINARY_DIR}/src/lib${MODULE_TARGET}.a
        ${BUILD_LIB_DIR}/lib${MODULE_TARGET}.a
    )

  endif()




#  add_custom_command( TARGET ${MODULE_TARGET} POST_BUILD
#    COMMAND ${CMAKE_COMMAND} -E make_directory
#      ${CMAKE_BINARY_DIR}/build/lib/gmlib/
#    COMMAND ${CMAKE_COMMAND} -E copy
#      ${CMAKE_BINARY_DIR}/modules/${MODULE}/lib${MODULE_TARGET}.a
#      ${CMAKE_BINARY_DIR}/build/lib/gmlib/lib${MODULE_TARGET}.a
#    COMMAND ${CMAKE_COMMAND} -E copy
#      ${CMAKE_BINARY_DIR}/modules/${MODULE}/lib${MODULE_TARGET}.a
#      ${CMAKE_BINARY_DIR}/lib/gmlib/lib${MODULE_TARGET}.a
#  )



endfunction(createModuleCopyCmds)

# Helper function for printing file info
function(printModuleSourceFiles)

  message( "\n\n\n" )

  message( "Module <" ${MODULE} "> source files" )

  message( "  Headers:" )
  foreach( HDR_ENTRY ${HEADERS} )
    message( "  - " ${HDR_ENTRY} )
    list( GET ${HDR_ENTRY} 0 CXX_HDR )
    list( GET ${HDR_ENTRY} 1 HDR_FILE )
    list( GET ${HDR_ENTRY} 2 HDR_LOC )

    extractHeaderRelPath( ${HDR_LOC} HDR_LOC_MOD )
    message( "  - " ${CXX_HDR} " (${HDR_FILE}) in \"${HDR_LOC_MOD}\"" )

  endforeach()

  message( "  Template Sources:" )
  foreach( TSRC ${TEMPLATE_SOURCES} )
    message( "  - " ${TSRC} )
  endforeach()

  message( "  Sources:" )
  foreach( SRC ${SOURCES} )
    message( "  - " ${SRC} )
  endforeach()


  message( "\n\n\n" )

endfunction(printModuleSourceFiles)

# Add module library target
function(addModuleLibrary)

  getModuleTargetHeaders( TARGET_HEADERS )
  getModuleTargetSources( TARGET_SOURCES )
  message( "Current source dir: " ${CMAKE_CURRENT_SOURCE_DIR} )
  add_library( ${MODULE_TARGET} STATIC ${TARGET_HEADERS} ${TARGET_SOURCES} )
endfunction(addModuleLibrary)

function(getModuleTargetHeaders TARGET_HEADERS )

  unset( THEADERS )
  foreach( HDR_SET ${HEADERS} )
    list( GET ${HDR_SET} 1 HDR_FILE )
    list( GET ${HDR_SET} 2 HDR_LOC )

    extractHeaderRelPath( ${HDR_LOC} HDR_LOC_MOD )
    if( HDR_LOC_MOD )
      set( THEADER "${MODULE}/${HDR_LOC_MOD}/${HDR_FILE}" )
    else()
      set( THEADER "${MODULE}/${HDR_FILE}" )
    endif()

    message( "THEADER: ${THEADER}" )
    list( APPEND THEADERS ${THEADER} )
  endforeach()

  set( ${TARGET_HEADERS} ${THEADERS} PARENT_SCOPE )
endfunction(getModuleTargetHeaders)

function(getModuleTargetSources TARGET_SOURCES)

  unset(TSOURCES)
  foreach( SRC ${SOURCES} )

    set( TSOURCE ${MODULE}/${SRC} )
    list( APPEND TSOURCES ${TSOURCE} )
  endforeach()

  set( ${TARGET_SOURCES} ${TSOURCES} PARENT_SCOPE )
endfunction(getModuleTargetSources)

function(extractHeaderRelPath HDR_REL_PATH_ENTRY HDR_REL_PATH )
  string( SUBSTRING ${HDR_REL_PATH_ENTRY} 7 -1 REL_PATH )
  set( ${HDR_REL_PATH} ${REL_PATH} PARENT_SCOPE )
endfunction(extractHeaderRelPath)

# Sets target build properties for current module
function(setModuleTargetProperties)

  set_target_properties( ${MODULE_TARGET} PROPERTIES DEBUG_POSTFIX _debug )
  set_target_properties( ${MODULE_TARGET} PROPERTIES LINKER_LANGUAGE CXX )
endfunction(setModuleTargetProperties)


# PRE_BUILD
# Create targets which generates CXX headers
function(generateModuleCXXHeaders)

  message( "Generating Module CXX Headers" )

  # Generate MODULE CXX headers
  unset( CXX_HEADER_INCLUDES )
  foreach( HEADER_SET ${HEADERS} )

    list( GET ${HEADER_SET} 0 CXX_HDR )
    list( GET ${HEADER_SET} 1 HDR )
    list( GET ${HEADER_SET} 2 HDR_RELPATH )
    extractHeaderRelPath( ${HDR_RELPATH} HDR_RELPATH_MOD )

    set( CXX_HEADER_INCLUDE "#include \"${MODULE}/${CXX_HDR}\"\n" )
    list( APPEND CXX_HEADER_INCLUDES ${CXX_HEADER_INCLUDE} )


    # Find header relative path, to module dir
    if( HDR_RELPATH_MOD )
      set( HDR_RELPATH_FILE ${HDR_RELPATH_MOD}/${HDR} )
    else()
      set( HDR_RELPATH_FILE ${HDR} )
    endif()

    # Define header include relative path
    file( RELATIVE_PATH BIN_SRC_RELPATH "${CMAKE_BINARY_DIR}" "${CMAKE_SOURCE_DIR}" )
    if( BIN_SRC_RELPATH )
      set( HEADER_INCLUDE "#include \"${HDR_RELPATH_FILE}\"" )
    else()
      file( RELATIVE_PATH MOD_SRC_CURRENT_RELPATH "${MODULE_BUILD_INCLUDE_DIR}" "${CMAKE_CURRENT_SOURCE_DIR}/${MODULE}" )
      set( HEADER_INCLUDE "#include \"${MOD_SRC_CURRENT_RELPATH}/${HDR_RELPATH_FILE}\"" )
    endif()

    # Generate individual CXX Header
    unset( VAR_CXX_HEADER_INCLUDES )
    set( VAR_CXX_HEADER_INCLUDES ${HEADER_INCLUDE} )
    configure_file(
      ${ICMAKE_TEMPLATE_DIR}/cxxheader.h
      ${MODULE_BUILD_INCLUDE_DIR}/${CXX_HDR}
      @ONLY
    )

  endforeach()

  # Generate module CXX Header
  unset( VAR_CXX_HEADER_INCLUDES )
  JOIN( "${CXX_HEADER_INCLUDES}" "" VAR_CXX_HEADER_INCLUDES )
  set( MODULE_CXX_HEADER_FILE "${BUILD_INCLUDE_DIR}/${LIB_PREFIX}${MODULE_NAME}${MODULE_SUFFIX}" )
  configure_file(
    ${ICMAKE_TEMPLATE_DIR}/cxxmoduleheader.h
    ${MODULE_CXX_HEADER_FILE}
    @ONLY
  )

endfunction(generateModuleCXXHeaders)


function(outputVarTest OUTPUT_VAR)

  set( ${OUTPUT_VAR} "test" PARENT_SCOPE )
endfunction(outputVarTest)


# POST_BUILD
# Copies generated module files and sources after module build
# Files to be compied are passed as arguments to the end of the function call
#function(add_module_cpy_commands MODULE MODULE_TARGET )
#
#  add_custom_command( TARGET ${MODULE_TARGET} POST_BUILD
#    COMMAND ${CMAKE_COMMAND} -E make_directory
#      ${CMAKE_BINARY_DIR}/build/lib/gmlib/
#    COMMAND ${CMAKE_COMMAND} -E copy
#      ${CMAKE_BINARY_DIR}/modules/${MODULE}/lib${MODULE_TARGET}.a
#      ${CMAKE_BINARY_DIR}/build/lib/gmlib/lib${MODULE_TARGET}.a
#    COMMAND ${CMAKE_COMMAND} -E copy
#      ${CMAKE_BINARY_DIR}/modules/${MODULE}/lib${MODULE_TARGET}.a
#      ${CMAKE_BINARY_DIR}/lib/gmlib/lib${MODULE_TARGET}.a
#  )
#
#  foreach(f ${ARGN})
#    add_custom_command( TARGET ${MODULE_TARGET} POST_BUILD
#      COMMAND ${CMAKE_COMMAND} -E make_directory
#        ${CMAKE_BINARY_DIR}/build/modules/${MODULE}
#      COMMAND ${CMAKE_COMMAND} -E copy
#        ${CMAKE_CURRENT_SOURCE_DIR}/${f}
#        ${CMAKE_BINARY_DIR}/build/modules/${MODULE}/${f}
#    )
#  endforeach(f)
#
#endfunction(add_module_cpy_commands)



